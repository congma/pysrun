#!/usr/bin/env python
"""A Python implementation of the SRUN 3000 internet tolling client.

Usage: pysrun [OPTIONS] {login|logout|kick}

This program is licensed under the BSD license.  You are free to use it
or modify it provided the conditions in the license are met. See the file
COPYRIGHT.


"""
import sys
import getopt
import getpass
import httplib
from urllib import urlencode
import urllib2
import functools
import os
from os.path import expanduser, abspath
import socket
import errno
import time
import struct
import atexit
import signal
import select
import resource
import stat
import logging
from ctypes import (CDLL, pointer, Structure, Union,
        c_void_p, c_char_p,
        c_uint32,
        c_uint8, c_uint16,
        c_ushort, c_short, c_uint, c_int,
        c_char, c_ubyte)
from ctypes.util import find_library


# Default configuration option values.
CONFIG = {"address": "172.16.202.201",
        "port": "3333",
        "uidfile": "~/.pysrun_uid",
        "interface": "eth0",
        "logpath": None}
# Mapping command-line options to configuration keys
OPT_CONFIG_MAP = {"-a": "address",
        "-P": "port",
        "-u": "username",
        "-p": "password",
        "-s": "uidfile",
        "-i": "interface",
        "-d": "debug",
        "-l": "logpath"}
# Server error message table. This, too, is just guesses.
ERRMSG = {"username_error": "invalid username",
        "password_error": "possibly invalid password",
        "ip_exist_error": "already authenticated",
        "online_num_error": "maximal number of online users exceeded",
        "version_error": "request rejected by server",
        "status_error": "payment required",
        "sync_error": "server sync not complete, try later",
        "mode_error": "authentication mode disabled by server",
        # logout_error seems to only occur when you do a kick with
        # no user online
        "logout_error": "can't force logout (nobody logged in?)",
        "uid_error": "session ID mismatch"}  # uid_error could occur on logout
# NOTE: Calling find_library to locate the dynamc C library will create
# external processes.  I think I'm better just do it once.
LIBC_NAME = find_library("c")           # E.g. "libc.so.6"
LIBC = CDLL(LIBC_NAME)
PLATFORM = os.uname()[0].lower()


# Implementation of getifaddrs()-based low-level function.
# Ref1: http://kbyanc.blogspot.com/2010/11/python-enumerating-ip-addresses-on.html
# Ref2: http://carnivore.it/2010/07/22/python_-_getifaddrs
# Reference for type definitions:
# BSD: Robert Watson's FXR: http://fxr.watson.org/
# Linux: Free Electrons: http://lxr.free-electrons.com/
#
# Linux: the broadcast and destination address pointers form a union (since
# the peer cannot be dst and brd at the same time).  On BSD the struct ifaddrs
# has two members for broadcast and destination separately.
class _linux_ifa_ifu_u(Union):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifu_broadaddr", c_void_p),
            ("ifu_dstaddr", c_void_p)]


# sockaddr-related structures
# For generic/unknown address family
class _bsd_sockaddr(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sa_len", c_uint8),
            ("sa_family", c_uint8),
            ("sa_data", (c_uint8 * 14))]


class _linux_sockaddr(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sa_family", c_uint16),
            ("sa_data", (c_uint8 * 14))]


# AF_PACKET / Linux
# Linux header: linux/if_packet.h, struct sockaddr_ll
class _linux_sockaddr_ll(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sll_family", c_ushort),
            ("sll_protocol", c_uint16),
            ("sll_ifindex", c_int),
            ("sll_hatype", c_short),
            ("sll_pkttype", c_uint8),
            ("sll_halen", c_uint8),
            ("sll_addr", (c_uint8 * 8))]

    def __str__(self):
        return ":".join(["%02x" % self.sll_addr[i]
            for i in range(self.sll_halen)])


# AF_LINK -- BSD family, struct sockaddr_dl
# BSD: net/if_dl.h
# Pretty-printer mixin for both long- and short-data variants.
class _BSDMacFormatterMixin(object):
    """

    Mixin class that added pretty-printing function to
    the Python classes that interface the various BSD sockaddr_dl
    structures.

    """
    def __str__(self):
        addrdata = self.sdl_data[self.sdl_nlen: self.sdl_nlen
                + self.sdl_alen]
        return ":".join(["%02x" % x for x in addrdata])


# The "short data" is used by NetBSD / OpenBSD.  The difference is subtle,
# as the 12-char data is defined as *minimum* requirement.
class _bsd_short_sockaddr_dl(Structure, _BSDMacFormatterMixin):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 12))]


# The "long data" version is used by FreeBSD / DragonFlyBSD.
class _bsd_long_sockaddr_dl(Structure, _BSDMacFormatterMixin):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 46))]


# struct in_addr: essentially common to Linux and BSD
class _in_addr(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("s_addr", c_uint32)]

    def __str__(self):
        return socket.inet_ntoa(struct.pack("@I", self.s_addr))


class _INETFormatterMixin(object):
    """

    Mix-in class for formatting AF_INET socket address structures.

    """
    def __str__(self):
        return str(self.sin_addr)


# BSD AF_INET (IPv4): netinet/in.h
class _bsd_sockaddr_in(Structure, _INETFormatterMixin):
    _fields_ = [
            ("sin_len", c_uint8),
            ("sin_family", c_uint8),
            ("sin_port", c_uint16),
            ("sin_addr", _in_addr),
            ("sin_zero", (c_char * 8))]


# Linux AF_INET: linux/in.h
class _linux_sockaddr_in(Structure, _INETFormatterMixin):
    _fields_ = [
            ("sin_family", c_ushort),
            ("sin_port", c_uint16),
            ("sin_addr", _in_addr),
            ("sin_zero", (c_ubyte * 8))]


# struct ifaddrs, see getifaddrs(3) man page.
# Linux: pointers to brd and dst form a union, takes one member in
# struct ifaddrs.
class _linux_ifaddrs(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_ifu", _linux_ifa_ifu_u),
            ("ifa_data", c_void_p)]


# BSD: pointers to brd and dst are two members.
class _bsd_ifaddrs(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_broadaddr", c_void_p),
            ("ifa_dstaddr", c_void_p),
            ("ifa_data", c_void_p)]


# Platform-specific initialization
if PLATFORM == "linux":
    AF_LINK = socket.AF_PACKET
else:
    # According to FreeBSD doc, this is AF_LINK.  See sys/socket.h
    # Currently, this is true for all BSDs we consider.
    # http://www.freebsd.org/doc/en/books/developers-handbook/sockets-essential-functions.html
    AF_LINK = 18
# The values of the lookup table are tuples organized by index:
# 0: The equivalent of struct ifaddrs, see ifaddrs.h, getifaddrs(3).
# 1: A dictionary with address families as keys and corresponding
#    sockaddr_xx structures as values.
# 2: The equivalent of struct sockaddr, see sys/socket.h.
PLATFORM_LOOKUP = {
    "linux": (_linux_ifaddrs,
        {AF_LINK: _linux_sockaddr_ll,
        socket.AF_INET: _linux_sockaddr_in},
        _linux_sockaddr),
    "freebsd": (_bsd_ifaddrs,
        {AF_LINK: _bsd_long_sockaddr_dl,
        socket.AF_INET: _bsd_sockaddr_in},
        _bsd_sockaddr),
    "dragonfly": (_bsd_ifaddrs,
        {AF_LINK: _bsd_long_sockaddr_dl,
        socket.AF_INET: _bsd_sockaddr_in},
        _bsd_sockaddr),
    "netbsd": (_bsd_ifaddrs,
        {AF_LINK: _bsd_short_sockaddr_dl,
        socket.AF_INET: _bsd_sockaddr_in},
        _bsd_sockaddr),
    "openbsd": (_bsd_ifaddrs,
        {AF_LINK: _bsd_short_sockaddr_dl,
        socket.AF_INET: _bsd_sockaddr_in},
        _bsd_sockaddr)}


def getaddrs():
    """Return a dictionary with each key being an interface name and
    the value being another dictionary.  The value dictionary has
    address families as keys, and a (possibly empty) list of addresses
    within that family as each key's value.  Currently the supported families
    are IPv4 (AF_INET) and Ethernet MAC address (AF_PACKET on Linux,
    AF_LINK on BSD).

    This function calls the platform's getifaddrs() implementation.

    """
    # Unpack just for the sake of being meaningful.
    ifaddrs, familydict, sockaddr = PLATFORM_LOOKUP[PLATFORM]
    ptr = c_void_p(None)
    result = LIBC.getifaddrs(pointer(ptr))
    if result != 0:
        return {}
    ifa = ifaddrs.from_address(ptr.value)
    result = {}

    while True:
        name = ifa.ifa_name  # name of network interface
        if name not in result:  # this interface not yet encountered
            # Initialize container directory for this interface.
            result[name] = {}
            for family in familydict:
                result[name][family] = []
        # Some interface (such as a TUN virtual network) doesn't give us
        # ifa_addr at all and we can usually skip them because they're hardly
        # relevant for our usage case.
        if ifa.ifa_addr:
            saddr = sockaddr.from_address(ifa.ifa_addr)
            for family, sockaddr_xx in familydict.iteritems():
                if saddr.sa_family == family:
                    sinterf = sockaddr_xx.from_address(ifa.ifa_addr)
                    addr = "%s" % sinterf
                    if addr:
                        result[name][family].append(addr)
        if ifa.ifa_next:
            ifa = ifaddrs.from_address(ifa.ifa_next)
        else:
            break

    LIBC.freeifaddrs(ptr)
    return result


def get_address(ifname, family, ifaddrdict):
    """Return a text representation of the address on an interface."""
    # It might be possible that more than one address is associated
    # with the interface.  If this is the case, we simply return the first.
    # If there's no such interface or the interface has no such kind of
    # address, we notify caller via ValueError.
    try:
        addr = ifaddrdict[ifname][family][0]
    except (IndexError, KeyError):
        raise ValueError("%s" % ifname)
    return addr


def become_daemon(stdin=None, stdout=None, stderr=None):
    """Become a daemon process before doing daemonic things.
    Return None.

    Paths can be specified so that the standard streams will be
    directed to them, facilitating logging, among others.
    If leaving any path to None, os.devnull will be used.

    All file descriptors up to the known limit will be closed, and
    the standard streams re-opened upon return.

    This function clears the umask.

    """
    # Ref1: Unix Programming FAQ, section 1.7,
    # "How do I get my program to act like a daemon?"
    # http://www.faqs.org/faqs/unix-faq/programmer/faq/
    # Ref2: W. Richard Stevens: Advanced Programming in the Unix Environment,
    # section 13.3
    # Ref3: Alex Martelli et al., eds., Python Cookbook
    # section 9.13 http://onlamp.com/python/pythoncook2/solution.csp?day=1
    # Ref4: http://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/
    # Make sure we are not process group leader and not possessing controlling
    # terminal
    try:
        pid = os.fork()
    except OSError as os_e:
        error("login (fork 1)", os_e, server=False, exitp=True, exitcode=4)
    if pid:  # parent
        os._exit(os.EX_OK)  # pylint: disable=W0212
    # Detaching from parent environment
    os.setsid()     # Run in new session
    # Become a non-leader
    try:
        pid = os.fork()
    except OSError as os_e:
        error("login (fork 2)", os_e, server=False, exitp=True, exitcode=1)
    if pid:
        os._exit(os.EX_OK)  # pylint: disable=W0212
    # Close all inherited file descriptors.  Note that not even the standard
    # input/output/errors are kept, because we've no idea where they're
    # redirected.
    maxnofile = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if maxnofile == resource.RLIM_INFINITY:
        maxnofile = 1024
    os.closerange(0, maxnofile)
    path_i, path_o, path_e = (os.devnull if x is None \
            else abspath(expanduser(x)) for x in (stdin, stdout, stderr))
    # Reopen standard streams.  Should guarantee stdin is 0, stdout 1, etc.
    sys.stdin = open(path_i, "r")
    sys.stdout = open(path_o, "a+")
    sys.stderr = open(path_e, "a+", 0)
    os.chdir("/")   # Prevent fs unmountability
    os.umask(0)


def read_config_file(path, warn=False):
    """Read the key-value pair configuration options from file located at path
    and return a dictionary of config options.

    If warn is True, warn against all non-conforming lines in addition to
    ignoring them.  Default: False.

    """
    lineno = 0
    result = {}
    fhandle = open(path, "r")
    for line in fhandle:
        lineno += 1
        try:
            record = pfilter(line)
        except CfgLineIsGarbage as garb:
            if warn and not garb.isblank:
                print >> sys.stderr, ("Debug: %s: line %d: column %d: "
                        "garbage in\n%s" % (path, lineno, garb.col, garb))
            continue
        result.update(record)
    fhandle.close()
    return result


class CfgLineIsGarbage(ValueError):
    """

    Exception class notifying the caller that the line being filtered
    is a garbage line.

    """
    def __init__(self, text, offending_col, isblank=False):
        """text should be the culprit text for which warning is issued
        offending_col should be the no. of the first offending column.

        """
        super(CfgLineIsGarbage, self).__init__(text, offending_col, isblank)
        self.text = text
        self.col = offending_col
        self.isblank = isblank
        return None

    def __str__(self):
        """Return a two-line representation of the culprit line.  The first
        output line is a copy of the line with trailing whitespace removed
        to save screen space.  The second line is used to show a cursor mark
        pointing to the first offending column.

        """
        return "%s\n" % self.text + " " * self.col + "^"


def pfilter(line):
    """Filter input configuration file line for meaningful key-value pair.
    Return a dictionary containing only such key-value pairs.

    See README for the format definition.

    """
    text = line.split("#")[0]  # First hash ('#') starts a comment.
    if not text.strip():  # Skip blank line and notify caller.
        raise CfgLineIsGarbage("", 0, isblank=True)
    bareline = line.rstrip()
    key, sep, val = text.partition("=")
    if not sep:  # Lines not containing the equal sign ('=') are discarded.
        raise CfgLineIsGarbage(bareline, len(bareline))
    nkey = key.strip()
    nval = val.strip()
    if not nkey:
        raise CfgLineIsGarbage(bareline, len(key))
    elif not nval:  # NOTE: Prevent empty value.  This may change...
        raise CfgLineIsGarbage(bareline, len(bareline))
    return {nkey: nval}


def read_uid(uid_path):
    """Search in the uid_path file for the uid used to end a session.  Stop and
    return on first match.

    Return a string stripped of leading and trailing whitespaces.

    """
    fhandle = open(uid_path, "r")
    for line in fhandle:
        bline = line.strip()
        if bline.isdigit():
            fhandle.close()
            return bline
    raise ValueError("no UID found in UID file (%s)" % uid_path)


def write_uid(uid, uid_path):
    """Write the UID uid to file at uid_path.  Catch file I/O failure
    and emit warning.  Return None.

    """
    try:
        fhandle = open(uid_path, "w")
        fhandle.write("%s\n" % uid)
        fhandle.close()
    except IOError as io_e:
        # This should not be an error, but a warning.  Log-in succeeds
        # anyway, you just can't store the uid.
        boiler = "Warning: login:"
        print >> sys.stderr, "%s can't write UID file (%s)" % (boiler, io_e)
        print >> sys.stderr, "%s the uid is: %s" % (boiler, uid)
    return None


def encode_txt(plaintxt, keytxt):
    """Encode plaintxt for sending using type=2 operation mode using keytxt.
    Return a string containing the encoded text.

    Ref: http://blog.sskaje.me/2009/04/srun3000.html

    """
    # Truncate or pad the key up to the length of plaintxt.
    if len(keytxt) >= len(plaintxt):
        padded_key = keytxt[0:len(plaintxt)]
    else:
        padded_key = keytxt * (len(plaintxt) / len(keytxt))
        padded_key += keytxt[0:len(plaintxt) % len(keytxt)]
    # Take the ASCII of both strings
    ordder = lambda s: [ord(c) for c in s]
    plain_asc = ordder(plaintxt)
    key_asc = ordder(padded_key)
    tmp = map(lambda x, y: x ^ y, plain_asc, key_asc)  # pylint: disable=W0141
    res = []
    for i in xrange(len(tmp)):
        lowpar = chr((tmp[i] & 0x0f) + 0x36)
        hipar = chr(((tmp[i] & 0xf0) >> 4) + 0x63)
        if i % 2:   # if odd index
            sec = "%s%s" % (hipar, lowpar)
        else:
            sec = "%s%s" % (lowpar, hipar)
        res.append(sec)
    return "".join(res)


def makekey(unixtime, offset=0):
    """Return the key text string based on the UNIX time and the given
    offset in seconds.

    """
    kstr = "%d" % ((unixtime + offset) / 60)
    return kstr[::-1]


class BoundHTTPHandler(urllib2.HTTPHandler):
    """HTTP Handler that can bind to local IP address."""
    # Ref: http://stackoverflow.com/a/14669175/418374

    def __init__(self, source_address=None, debuglevel=0):
        # urllib2.HTTPHandler is an old-style class so no super() call.
        urllib2.HTTPHandler.__init__(self, debuglevel)
        self.http_class = functools.partial(httplib.HTTPConnection,
                source_address=source_address)

    def http_open(self, req):
        return self.do_open(self.http_class, req)


def communicate_to_server(url, postdata, prefix, local_ip=""):
    """Communicate to the authentication/app gateway server by HTTP messages,
    with data sent using the POST method.

    If local_ip is specified, will bind to that address with port 0 (arbitrary
    non-privileged port).

    Return the document received from server, unchanged.  It is up to the
    caller to decide what to do with the document.

    """
    # Ref: http://stackoverflow.com/a/14669175/418374
    handler = BoundHTTPHandler(source_address=(local_ip, 0))
    opener = urllib2.build_opener(handler)
    try:
        docf = opener.open(url, postdata)
    except urllib2.URLError as url_e:
        error(prefix, "can't communicate to server (%s)" % url_e.reason,
                exitcode=4)
    msg = docf.read()
    docf.close()
    return msg


def _logexit():
    """To be registered as atexit hook.  Log exiting event."""
    logging.debug("exiting")


def shandler(signum, frame):  # pylint: disable=W0613,C0111
    """signal handler that does clean shutdown on receiving SIGTERM
    by calling sys.exit(), handing over to already registered atexit
    handlers.  Other signals that normally causes termination are logged
    and ignored.

    """
    if signum == signal.SIGTERM:
        logging.debug("received signal %s", signum)
        sys.exit(0)  # will call atexit handlers
    else:
        logging.debug("received signal %s, ignoring", signum)


def unbind_control_sock():
    """Clean up control socket on exit.  To be registered as atexit
    callback.

    """
    logging.debug("trying to reclaim named socket file")
    try:
        os.unlink("/tmp/pysrun.sock")
    except OSError as os_e:
        logging.debug("can't reclaim named socket file (%s)", os_e)
    else:
        logging.debug("reclaimed named socket file")


def daemon(cfg, num_info):
    """Daemon process."""
    siglist = [signal.SIGHUP, signal.SIGTERM, signal.SIGUSR1, signal.SIGUSR2]
    logging.basicConfig(format="[%(asctime)s] %(process)d:" \
            "%(levelname)s:%(message)s",
            level=(logging.DEBUG if "debug" in cfg else logging.INFO),
            stream=sys.stderr)
    atexit.register(_logexit)
    atexit.register(unbind_control_sock)
    for sig in siglist:
        signal.signal(sig, shandler)
    # The rationale of using stream socket is to get a peer HUP event on
    # peer exit.  This can be used to monitor peer death even if it's uncleanly
    # killed.  Stream UDS is essentially full-duplex pipe, see W. Richard
    # Stevens' book, section 17.3.
    psock, csock = socket.socketpair(socket.AF_UNIX, socket.SOCK_STREAM)
    poller = select.poll()
    pid = os.fork()
    if pid:  # parent
        logging.debug("command listener started")
        csock.close()
        daemon_cmdlistener(psock, poller)
    else:  # child
        logging.debug("hearbeater started (uid %s)", num_info[0])
        psock.close()
        daemon_heartbeater(csock, poller, cfg, num_info)


def daemon_cmdlistener(peersock, poller):
    """Daemon subprocess: command listener (parent)."""
    pfd = peersock.fileno()
    ctrlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    ctrlfd = ctrlsock.fileno()
    os.fchmod(ctrlfd, stat.S_IRWXU & (~stat.S_IRWXG) & (~stat.S_IRWXO))
    ctrlsock.bind("/tmp/pysrun.sock")
    logging.debug("bound to socket address /tmp/pysrun.sock")
    poller.register(pfd, select.POLLIN)
    poller.register(ctrlfd, select.POLLIN)
    statdict = dict(poller.poll())
    if pfd in statdict and (statdict[pfd] & select.POLLHUP):
        # peer exit
        logging.debug("received peer exit event")
    if ctrlfd in statdict and ctrlsock.recv(128) == "DIE":
        logging.debug("received local exit command")
    sys.exit(0)


def daemon_heartbeater(peersock, poller, cfg, num_info):
    """Daemon subprocess: heartbeater (parent)."""
    pfd = peersock.fileno()
    poller.register(pfd, select.POLLIN)
    srvaddr = (socket.gethostbyname(cfg["address"]), 3335)
    uidmsg = struct.pack("<q", num_info[0])
    while True:
        statlist = poller.poll(60000)  # 1 min in milliseconds
        if not statlist:    # timeout
            msg = do_heartbeat(srvaddr, uidmsg, cfg["ipinuse"])
            if msg == -2:
                logging.info("received death ping from server")
                break
        elif statlist[0][1] & select.POLLHUP:   # peer exit
            logging.debug("received peer exit event")
            break
    sys.exit(0)


def do_heartbeat(srvaddr, message, local_ip=""):
    """Once-per-minute UDP heartbeat.
    Return the "signed long long" data received from server on succcess.
    If the server times out in 0.5 seconds, or sends what we perceive as
    garbage, or we fail to receive from the server at all, return None.

    """
    retnum = None
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((local_ip, 0))
    sock.sendto(message, srvaddr)
    logging.debug("heartbeat message sent to server (%r, %s:%s)",
            message, *srvaddr)
    # 0.5 seconds of recv timeout should be long enough
    # for communication and short enough for performance.
    sock.settimeout(0.5)
    try:
        retmsg = sock.recvfrom(128)
    except socket.timeout:
        logging.warning("server timed out for returning heartbeat")
        # Ignore it? Don't know what should be done...
    else:
        if retmsg[1] == srvaddr:    # received message is from server
            # Don't ask about the endianness...
            retnum = struct.unpack("<q", retmsg[0][:8])[0]
            logging.debug("received server hearbeat (%s)", retnum)
        else:
            logging.warning("response not from server (%r, %s:%s)",
                    retmsg[0], *retmsg[1])
    finally:
        sock.close()
    return retnum


def cleanup_daemon_leftover():
    """Clean up leftover daemon processes and named socket file, if
    any.

    """
    controlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    try:
        controlsock.bind("/tmp/pysrun.sock")
    except socket.error as so_e:
        if so_e.errno == errno.EADDRINUSE:
            # reclaim leftover process
            try:
                controlsock.sendto("DIE", "/tmp/pysrun.sock")
            except socket.error:
                pass
        else:
            raise so_e
    finally:
        controlsock.close()
        # reclaim leftover address
        try:
            os.unlink("/tmp/pysrun.sock")
        except OSError:
            pass


def login(cfg):
    """The login sequence.  Kill any known background daemon as late
    as possible.  On successful login, create and hand over to the daemon.

    """
    url = "http://%s:%s/cgi-bin/do_login" % (cfg["address"], cfg["port"])
    try:
        mac = get_address(cfg["interface"], AF_LINK, cfg["ifaddrs"])
    except ValueError as val_e:
        error("login", "no MAC address information for interface (%s)" % val_e,
                exitcode=4)
    try:
        localip = get_address(cfg["interface"], socket.AF_INET, cfg["ifaddrs"])
    except ValueError as val_e:
        error("login", "no IPv4 address information for interface (%s)" \
                % val_e, exitcode=4)
    cfg["ipinuse"] = localip
    login_data = {"username": cfg["username"],
        "drop": "0",
        "type": "2",
        "n": "100"}
    offset = 0
    n_attempt = 0
    max_attempt = 3
    while n_attempt < max_attempt:  # XXX hard-coded, for testing only
        ourtime = time.time()
        key = makekey(ourtime, offset)
        login_data["password"] = encode_txt(cfg["password"], key)
        login_data["mac"] = encode_txt(mac, key)
        login_postdata = urlencode(login_data)
        # Send data and receive response.
        # Expect either uid or server exception message.
        msg = communicate_to_server(url, login_postdata, "login", localip)
        # Analyse return message.
        try:    # Try as message of success
            num_info = _get_info_from_msg(msg)
        except ValueError:  # Not a message of success
            # Then try decoding as password_error@timestamp format
            try:
                offset = _get_offset_from_msg(ourtime, msg)
            except ValueError:  # Not in password_error@timestamp format
                break
            # XXX hard-coded
            time.sleep(1)
            n_attempt += 1
            continue
        # Success with getting the uid
        write_uid(num_info[0], expanduser(cfg["uidfile"]))
        cleanup_daemon_leftover()
        # Forking into background a heartbeat keeper.
        become_daemon(stderr=cfg["logpath"])
        daemon(cfg, num_info)
        # The control flow should be handed to daemon() in another
        # process so there's no need of leaving the while loop.
    # If the program ever reaches here, we have a server-generated error.
    # We should strip any possible @timestamp tails before signalling.
    msg += "s"  # sentinel
    error("login", msg[:msg.find("@")], server=True)


def _get_info_from_msg(text):
    """Get the information from a well-formed message returned for
    successful login.  Return a list of 5 numbers.

    Tentative format is
    uid, IP address padded with 8 bytes of status string, bytes left,
    unknown field possibly 0, 0 or timestamp of expiry date.

    """
    fields = text.split(",")
    if len(fields) != 5:
        raise ValueError
    nums = [int(n) for n in fields]
    return nums


def _get_offset_from_msg(unixtime, text, prefix="password_error@"):
    """Parse the text, retrieve the timestamp, and calculate the offset.
    Return the numerical offset as a float.

    """
    if not text.startswith(prefix):
        raise ValueError
    theirtime = int(text[len(prefix):])
    return theirtime - unixtime


def _ask_daemon_to_die():
    """Ask daemon to quit.  Ignore possible socket errors, because
    we have nothing to do after this.

    """
    controlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    try:
        controlsock.sendto("DIE", "/tmp/pysrun.sock")
    except socket.error:
        pass
    finally:
        controlsock.close()


def logout(cfg):
    """The logout sequence."""
    try:
        uid = read_uid(expanduser(cfg["uidfile"]))
    except IOError as io_e:
        error("logout", "can't read from UID file (%s)" % io_e,
                exitcode=4)
    except ValueError as val_e:  # read_uid() reads non-uid
        error("logout", "%s" % val_e,
                exitcode=2)
    try:
        localip = get_address(cfg["interface"], socket.AF_INET, cfg["ifaddrs"])
    except ValueError as val_e:
        error("login", "no IPv4 address information for interface (%s)" \
                % val_e, exitcode=4)
    url = "http://%s:%s/cgi-bin/do_logout" % (cfg["address"], cfg["port"])
    logout_data = {"uid": uid}
    logout_postdata = urlencode(logout_data)
    msg = communicate_to_server(url, logout_postdata, "logout", localip)
    stext = msg.strip()
    if stext != "logout_ok":    # NOTE: Magic constant used.
        error("logout", stext, server=True)
    else:   # Log-out success
        _ask_daemon_to_die()
    return None


def kick(cfg):
    """Kick all users using the account."""
    url = "http://%s:%s/cgi-bin/force_logout" % (cfg["address"], cfg["port"])
    kick_data = {"username": cfg["username"],
            "password": cfg["password"]}
    kick_postdata = urlencode(kick_data)
    msg = communicate_to_server(url, kick_postdata, "kick")
    stext = msg.strip()
    if stext != "logout_ok":    # NOTE: Magic constant used.
        error("kick", stext, server=True)
    else:   # Kick success
        _ask_daemon_to_die()
    return None


def error(prefix, txt, server=False, exitp=True, exitcode=2):
    """Do error messaging.

    prefix announces which component has failed.  txt is a text message
    describing the specific failure.

    If exitp is True, call sys.exit() to exit with exitcode, otherwise don't
    exit and return the message printed.  If exit is False, exitcode is
    ignored.

    The flag server should be set to True if the exception is notified by
    the server.  This causes the pretty-printer to do some extra formatting
    and always exit with code 1.  Therefore, when server is True, neither
    exitp nor exitcode has any effect.

    """
    if server:
        if txt in ERRMSG:
            msg = "Error: %s: server indicates error: %s" % (prefix,
                    ERRMSG[txt])
            exitcode = 1
        else:
            msg = "Error: %s: unknown server error (%s)" % (prefix, txt)
            exitcode = 8
        exitp = True
    else:
        msg = "Error: %s: %s" % (prefix, txt)
    print >> sys.stderr, "%s" % msg
    if exitp:
        sys.exit(exitcode)
    else:
        return msg


def have(keylist, dic):
    """Check whether all keys in keylist are present in dic and all keys
    has values evaluating to True.  Return a boolean.

    """
    return all(key in dic and dic[key] for key in keylist)


def show_usage(fail=True):
    """Show help message.  If fail, the message is written to stderr
    and the program exits with status 2.  If fail is False, write to stdout
    and return None.

    """
    stream = sys.stderr if fail else sys.stdout
    msglist = ["Usage: pysrun [Options] {login|logout|kick}",
            "Options:",
            "  -c FILE       path to configuration file",
            "  -I            propmt interactively for password",
            "  -u USERNAME   account username",
            "  -p PASSWORD   account password",
            "  -a ADDRESS    address of authentication server",
            "  -P PORT       authentication server listening port",
            "  -i INTERFACE  network interface used for MAC address retrieval",
            "  -s FILE       path to session UID storage file",
            "  -d            show debug output and log debug messages",
            "  -l FILE       path to log file",
            "  -h            display this message and exit"]
    print >> stream, "\n".join(msglist)
    if fail:
        sys.exit(2)
    return None


def transform_to_config(inputdic):
    """Translate the keys in inputdic to the corresponding config
    dictionary key name.

    Return the transformed dictionary object useful for updating the config
    dictionary.

    """
    result = {}
    for key, value in inputdic.iteritems():
        if key in OPT_CONFIG_MAP:
            result[OPT_CONFIG_MAP[key]] = value
    return result


def isvalidport(txt):
    """Returns True if txt represents a valid TCP port (in dec)."""
    return txt.isdigit() and int(txt) <= 65535 and int(txt) >= 0


def human_enum(strlist):
    """Return a human-readable textual enumeration of the strings in the list

    strlist."""
    cleantxtlist = []
    for item in strlist:
        word = str(item).strip()
        if word:
            cleantxtlist.append(word)
    head = cleantxtlist[:-1]
    tail = cleantxtlist[-1:]
    hstr = ", ".join(head)
    return " and ".join([hstr] + tail if hstr else tail)


def main():  # pylint: disable=C0111
    optspec = "hc:dI"
    optspec += "".join([("%s:" % key.strip("-")) for key in OPT_CONFIG_MAP])
    # Get options and arguments, emit help message on bad options.
    try:
        oplist, args = getopt.gnu_getopt(sys.argv[1:], optspec)
    except getopt.GetoptError as go_e:
        error("config", "%s" % go_e, exitp=False)
        show_usage(fail=True)  # be explicit
    opdict = dict(oplist)
    if "-h" in opdict:  # Exit as early as possible if "-h" is in options.
        show_usage(fail=False)
        sys.exit(0)
    # Determine the operation from cmdline, fail if none find.
    operation_table = {"login": login,
            "logout": logout,
            "kick": kick}
    valid_oprs = operation_table.viewkeys() & args
    if len(valid_oprs) != 1:  # One and only one operation allowed.
        show_usage(fail=True)
    the_opr = valid_oprs.pop()
    # Update config info from all sources we have.
    config_from_cmdline = transform_to_config(opdict)
    config_path = expanduser(opdict.get("-c", "~/.pysrun.cfg"))
    try:
        config_from_file = read_config_file(config_path, warn=("-d" in opdict))
    except IOError as io_e:
        error("config", "can't read configuration file (%s)" % io_e,
                exitcode=4)
    # Overriding priorities: command-line > config file > defaults.
    CONFIG.update(config_from_file)
    CONFIG.update(config_from_cmdline)
    # Interactive password overrides all other forms of password input.
    if "-I" in opdict and the_opr != "logout":
        CONFIG["password"] = getpass.getpass()
    # Validation of config and its values.
    if not isvalidport(CONFIG["port"]):
        error("config", "invalid port number (%s)" % CONFIG["port"],
                exitcode=2)
    # Kicking can use whatever connection available, but log-in/-out
    # requires address matching (XXX: not tested yet)
    required_keys = {"login": ["username", "password", "interface"],
            "logout": ["uidfile", "interface"],
            "kick": ["username", "password"]}
    if not have(required_keys[the_opr], CONFIG):
        error("config", "operation \"%s\" requires the option%s %s" %
                (the_opr, "s" if len(required_keys[the_opr]) > 1 else "",
                    human_enum(required_keys[the_opr])),
                exitcode=2)
    # All operations needs to know the current network status
    CONFIG["ifaddrs"] = getaddrs()
    operation_table[the_opr](CONFIG)


if __name__ == "__main__":
    main()
