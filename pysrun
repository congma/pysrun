#!/usr/bin/env python
"""A Python implementation of the SRUN 3000 internet tolling client.

Usage: pysrun [OPTIONS] {login|logout|kick}

This program is licensed under the BSD license.  You are free to use it
or modify it provided the conditions in the license are met. See the file
COPYRIGHT.


"""
import sys
import getopt
import getpass
from urllib import urlencode
import urllib2
import os
from os.path import expanduser
import socket
import errno
import time
import struct
import atexit
import signal
import select
import resource
from ctypes import (CDLL, pointer, Structure, Union,
        c_void_p, c_char_p,
        c_uint8, c_uint16,
        c_ushort, c_short, c_uint, c_int)
from ctypes.util import find_library


# Default configuration option values.
CONFIG = {"address": "172.16.202.201",
        "port": "3333",
        "uidfile": "~/.pysrun_uid",
        "interface": "eth0"}
# Mapping command-line options to configuration keys
OPT_CONFIG_MAP = {"-a": "address",
        "-P": "port",
        "-u": "username",
        "-p": "password",
        "-s": "uidfile",
        "-i": "interface"}
# Server error message table. This, too, is just guesses.
ERRMSG = {"username_error": "invalid username",
        "password_error": "possibly invalid password",
        "ip_exist_error": "already authenticated",
        "online_num_error": "maximal number of online users exceeded",
        "version_error": "request rejected by server",
        "status_error": "payment required",
        "sync_error": "server sync not complete, try later",
        "mode_error": "authentication mode disabled by server",
        # logout_error seems to only occur when you do a kick with
        # no user online
        "logout_error": "can't force logout (nobody logged in?)",
        "uid_error": "session ID mismatch"}  # uid_error could occur on logout
# NOTE: Calling find_library to locate the dynamc C library will create
# external processes.  I think I'm better just do it once.
LIBC_NAME = find_library("c")           # E.g. "libc.so.6"
LIBC = CDLL(LIBC_NAME)
PLATFORM = os.uname()[0].lower()


# Implementation of getifaddrs()-based MAC functions.
# Ref1: http://kbyanc.blogspot.com/2010/11/python-enumerating-ip-addresses-on.html
# Ref2: http://carnivore.it/2010/07/22/python_-_getifaddrs

# Linux: the broadcast and destination address pointers form a union (since
# the peer cannot be dst and brd at the same time).  On BSD the struct ifaddrs
# has two members for broadcast and destination separately.
class _linux_ifa_ifu_u(Union):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifu_broadaddr", c_void_p),
            ("ifu_dstaddr", c_void_p)]


# sockaddr-related structures
# For generic/unknown address family
class _bsd_sockaddr(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sa_len", c_uint8),
            ("sa_family", c_uint8),
            ("sa_data", (c_uint8 * 14))]


class _linux_sockaddr(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sa_family", c_uint16),
            ("sa_data", (c_uint8 * 14))]


# AF_PACKET / Linux
# Linux header: linux/if_packet.h, struct sockaddr_ll
class _linux_sockaddr_ll(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("sll_family", c_ushort),
            ("sll_protocol", c_uint16),
            ("sll_ifindex", c_int),
            ("sll_hatype", c_short),
            ("sll_pkttype", c_uint8),
            ("sll_halen", c_uint8),
            ("sll_addr", (c_uint8 * 8))]

    def __str__(self):
        return ":".join(["%02x" % self.sll_addr[i]
            for i in range(self.sll_halen)])


# AF_LINK -- BSD family, struct sockaddr_dl
# BSD: net/if_dl.h
# Pretty-printer mixin for both long- and short-data variants.
class _BSDMacFormatterMixin(object):
    """

    Mixin class that added pretty-printing function to
    the Python classes that interface the various BSD sockaddr_dl
    structures.

    """
    def __str__(self):
        addrdata = self.sdl_data[self.sdl_nlen: self.sdl_nlen
                + self.sdl_alen]
        return ":".join(["%02x" % x for x in addrdata])


# The "short data" is used by NetBSD / OpenBSD.  The difference is subtle,
# as the 12-char data is defined as *minimum* requirement.
class _bsd_short_sockaddr_dl(Structure, _BSDMacFormatterMixin):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 12))]


# The "long data" version is used by FreeBSD / DragonFlyBSD.
class _bsd_long_sockaddr_dl(Structure, _BSDMacFormatterMixin):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 46))]


# struct ifaddrs, see getifaddrs(3) man page.
# Linux: pointers to brd and dst form a union, takes one member in
# struct ifaddrs.
class _linux_ifaddrs(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_ifu", _linux_ifa_ifu_u),
            ("ifa_data", c_void_p)]


# BSD: pointers to brd and dst are two members.
class _bsd_ifaddrs(Structure):  # pylint: disable=C0103,C0111
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_broadaddr", c_void_p),
            ("ifa_dstaddr", c_void_p),
            ("ifa_data", c_void_p)]


# Platform-specific initialization
if PLATFORM == "linux":
    AF_LINK = socket.AF_PACKET
else:
    # According to FreeBSD doc, this is AF_LINK.  See sys/socket.h
    # Currently, this is true for all BSDs we consider.
    # http://www.freebsd.org/doc/en/books/developers-handbook/sockets-essential-functions.html
    AF_LINK = 18
# The values of the lookup table are tuples organized in the following manner:
# Index 0: The equivalent of struct ifaddrs, see ifaddrs.h, getifaddrs(3).
# Index 1: The equivalent of struct sockaddr_ll (Linux, see netpacket/packet.h)
#          or sockaddr_dl (BSD, see net/if_dl.h).
# Index 2: The equivalent of struct sockaddr, see sys/socket.h.
PLATFORM_LOOKUP = {"linux": (_linux_ifaddrs,
    _linux_sockaddr_ll, _linux_sockaddr),
    "freebsd": (_bsd_ifaddrs, _bsd_long_sockaddr_dl, _bsd_sockaddr),
    "dragonfly": (_bsd_ifaddrs, _bsd_long_sockaddr_dl, _bsd_sockaddr),
    "netbsd": (_bsd_ifaddrs, _bsd_short_sockaddr_dl, _bsd_sockaddr),
    "openbsd": (_bsd_ifaddrs, _bsd_short_sockaddr_dl, _bsd_sockaddr)}


def getmacaddrs():
    """Return a dictionary with each key being an interface name and
    the value being a list of corresponding MAC addresses (possibly empty), in
    textual representation.

    This function calls the platform's getifaddrs() implementation.

    """
    # Unpack just for the sake of being meaningful.
    ifaddrs, sockaddr_dl, sockaddr = PLATFORM_LOOKUP[PLATFORM]
    ptr = c_void_p(None)
    result = LIBC.getifaddrs(pointer(ptr))
    if result != 0:
        return {}
    ifa = ifaddrs.from_address(ptr.value)
    result = {}

    while True:
        name = ifa.ifa_name
        if name not in result:
            result[name] = []
        # Some interface (such as a TUN virtual network) doesn't give us
        # ifa_addr at all and we can usually skip them because they're hardly
        # relevant for our usage case.
        if ifa.ifa_addr:
            saddr = sockaddr.from_address(ifa.ifa_addr)
            if saddr.sa_family == AF_LINK:
                sinterf = sockaddr_dl.from_address(ifa.ifa_addr)
                addr = "%s" % sinterf
                if addr:
                    result[name].append(addr)
        if ifa.ifa_next:
            ifa = ifaddrs.from_address(ifa.ifa_next)
        else:
            break

    LIBC.freeifaddrs(ptr)
    return result


def get_hwaddress(ifname):
    """Return a text representation of the HW address of an interface."""
    # It might be possible that more than one link-layer address is associated
    # with the interface.  If this is the case, we simply return the first.
    # If there's no such interface or the interface has no MAC address,
    # we notify caller via ValueError.
    macdict = getmacaddrs()
    try:
        addr = macdict[ifname][0]
    except (IndexError, KeyError):
        raise ValueError("%s" % ifname)
    return addr


def become_daemon(stdin=None, stdout=None, stderr=None):
    """Become a daemon process before doing daemonic things.

    Paths can be specified so that the standard streams will be
    directed to them, facilitating logging, among others.
    If leaving any path to None, os.devnull will be used.

    All file descriptors up to the known limit will be closed, and
    the standard streams re-opened upon return.

    This function clears the umask and returns the old umask.

    """
    # Ref1: Unix Programming FAQ, section 1.7,
    # "How do I get my program to act like a daemon?"
    # http://www.faqs.org/faqs/unix-faq/programmer/faq/
    # Ref2: W. Richard Stevens: Advanced Programming in the Unix Environment,
    # section 13.3
    # Ref3: Alex Martelli et al., eds., Python Cookbook
    # section 9.13 http://onlamp.com/python/pythoncook2/solution.csp?day=1
    # Ref4: http://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/
    # Make sure we are not process group leader and not possessing controlling
    # terminal
    try:
        pid = os.fork()
    except OSError as os_e:
        error("login (fork 1)", os_e, server=False, exitp=True, exitcode=4)
    if pid:  # parent
        os._exit(os.EX_OK)  # pylint: disable=W0212
    # Detaching from parent environment
    oldmask = os.umask(0)     # Clear inherited umask
    os.chdir("/")   # Prevent fs unmountability
    os.setsid()     # Run in new session
    # Become a non-leader
    try:
        pid = os.fork()
    except OSError as os_e:
        error("login (fork 2)", os_e, server=False, exitp=True, exitcode=1)
    if pid:
        os._exit(os.EX_OK)  # pylint: disable=W0212
    # Close all inherited file descriptors.  Note that not even the standard
    # input/output/errors are kept, because we've no idea where they're
    # redirected.
    maxnofile = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if maxnofile == resource.RLIM_INFINITY:
        maxnofile = 1024
    os.closerange(0, maxnofile)
    path_i, path_o, path_e = (os.devnull if x is None else x \
            for x in (stdin, stdout, stderr))
    # Reopen standard streams.  Should guarantee stdin is 0, stdout 1, etc.
    sys.stdin = open(path_i, "r")
    sys.stdout = open(path_o, "a+")
    sys.stderr = open(path_e, "a+", 0)
    return oldmask


def read_config_file(path, warn=False):
    """Read the key-value pair configuration options from file located at path
    and return a dictionary of config options.

    If warn is True, warn against all non-conforming lines in addition to
    ignoring them.  Default: False.

    """
    lineno = 0
    result = {}
    fhandle = open(path, "r")
    for line in fhandle:
        lineno += 1
        try:
            record = pfilter(line)
        except CfgLineIsGarbage as garb:
            if warn and not garb.isblank:
                print >> sys.stderr, ("Debug: %s: line %d: column %d: "
                        "garbage in\n%s" % (path, lineno, garb.col, garb))
            continue
        result.update(record)
    fhandle.close()
    return result


class CfgLineIsGarbage(ValueError):
    """

    Exception class notifying the caller that the line being filtered
    is a garbage line.

    """
    def __init__(self, text, offending_col, isblank=False):
        """text should be the culprit text for which warning is issued
        offending_col should be the no. of the first offending column.

        """
        super(CfgLineIsGarbage, self).__init__(text, offending_col, isblank)
        self.text = text
        self.col = offending_col
        self.isblank = isblank
        return None

    def __str__(self):
        """Return a two-line representation of the culprit line.  The first
        output line is a copy of the line with trailing whitespace removed
        to save screen space.  The second line is used to show a cursor mark
        pointing to the first offending column.

        """
        return "%s\n" % self.text + " " * self.col + "^"


def pfilter(line):
    """Filter input configuration file line for meaningful key-value pair.
    Return a dictionary containing only such key-value pairs.

    See README for the format definition.

    """
    text = line.split("#")[0]  # First hash ('#') starts a comment.
    if not text.strip():  # Skip blank line and notify caller.
        raise CfgLineIsGarbage("", 0, isblank=True)
    bareline = line.rstrip()
    key, sep, val = text.partition("=")
    if not sep:  # Lines not containing the equal sign ('=') are discarded.
        raise CfgLineIsGarbage(bareline, len(bareline))
    nkey = key.strip()
    nval = val.strip()
    if not nkey:
        raise CfgLineIsGarbage(bareline, len(key))
    elif not nval:  # NOTE: Prevent empty value.  This may change...
        raise CfgLineIsGarbage(bareline, len(bareline))
    return {nkey: nval}


def read_uid(uid_path):
    """Search in the uid_path file for the uid used to end a session.  Stop and
    return on first match.

    Return a string stripped of leading and trailing whitespaces.

    """
    fhandle = open(uid_path, "r")
    for line in fhandle:
        bline = line.strip()
        if bline.isdigit():
            fhandle.close()
            return bline
    raise ValueError("no UID found in UID file (%s)" % uid_path)


def write_uid(uid, uid_path):
    fhandle = open(uid_path, "w")
    fhandle.write("%s\n" % uid)
    fhandle.close()
    return None


def encode_txt(plaintxt, keytxt):
    """Encode plaintxt for sending using type=2 operation mode using keytxt.
    Return a string containing the encoded text.

    Ref: http://blog.sskaje.me/2009/04/srun3000.html

    """
    # Truncate or pad the key up to the length of plaintxt.
    if len(keytxt) >= len(plaintxt):
        padded_key = keytxt[0:len(plaintxt)]
    else:
        padded_key = keytxt * (len(plaintxt) / len(keytxt))
        padded_key += keytxt[0:len(plaintxt) % len(keytxt)]
    # Take the ASCII of both strings
    ordder = lambda s: [ord(c) for c in s]
    plain_asc = ordder(plaintxt)
    key_asc = ordder(padded_key)
    tmp = map(lambda x, y: x ^ y, plain_asc, key_asc)  # pylint: disable=W0141
    res = []
    for i in xrange(len(tmp)):
        lowpar = chr((tmp[i] & 0x0f) + 0x36)
        hipar = chr(((tmp[i] & 0xf0) >> 4) + 0x63)
        if i % 2:   # if odd index
            sec = "%s%s" % (hipar, lowpar)
        else:
            sec = "%s%s" % (lowpar, hipar)
        res.append(sec)
    return "".join(res)


def makekey(unixtime, offset=0):
    """Return the key text string based on the UNIX time and the given
    offset in seconds.

    """
    kstr = "%d" % ((unixtime + offset) / 60)
    return kstr[::-1]


def communicate_to_server(url, postdata, prefix):
    """Communicate to the authentication/app gateway server by HTTP messages,
    with data sent using the POST method.

    Return the document received from server, unchanged.  It is up to the
    caller to decide what to do with the document.

    """
    try:
        docf = urllib2.urlopen(url, postdata)
    except urllib2.URLError as url_e:
        error(prefix, "can't communicate to server (%s)" % url_e.reason,
                exitcode=4)
    msg = docf.read()
    docf.close()
    return msg


def _announce_peer_exit(sock):
    """To be registered as atexit hook.  Announce peer exit event
    via the UDS sock.

    """
    try:
        sock.send("DEAD")
    except socket.error:
        pass


def handlerfactory(sock):
    """Create signal handler that sends exit announcement to sock.
    Return the manufactured function.

    """
    def handler(signum, frame):  # pylint: disable=W0613,C0111
        _announce_peer_exit(sock)
    return handler


def unbind_control_sock():
    """Clean up control socket on exit.  To be registered as atexit
    callback.

    """
    try:
        os.unlink("/tmp/pysrun.sock")
    except OSError:
        pass


def daemon(cfg, num_info, umask):
    """Daemon process."""
    os.umask(umask)
    psock, csock = socket.socketpair(socket.AF_UNIX, socket.SOCK_DGRAM)
    siglist = [signal.SIGHUP, signal.SIGTERM, signal.SIGUSR1, signal.SIGUSR2]
    pid = os.fork()
    if pid:  # parent
        csock.close()
        controlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        controlsock.bind("/tmp/pysrun.sock")
        atexit.register(_announce_peer_exit, psock)
        atexit.register(unbind_control_sock)
        shandler = handlerfactory(psock)
        for sig in siglist:
            signal.signal(sig, shandler)
        while True:
            rlist, wlist, xlist = select.select([psock, controlsock], [], [])
            if psock in rlist and psock.recv(128) == "DEAD":  # peer exit
                break
            if controlsock in rlist and controlsock.recv(128) == "DIE":
                break
        sys.exit(0)
    else:  # child
        psock.close()
        atexit.register(_announce_peer_exit, csock)
        shandler = handlerfactory(psock)
        for sig in siglist:
            signal.signal(sig, shandler)
        csock.settimeout(60)
        srvaddr = (socket.gethostbyname(cfg["address"]), 3335)
        uidmsg = struct.pack("<q", num_info[0])
        while True:
            try:
                data = csock.recv(128)
            except socket.timeout:
                msg = do_heartbeat(srvaddr, uidmsg)
                if msg == -2:
                    sys.exit(0)
            else:
                if data == "DEAD":  # peer exit
                    sys.exit(0)


def do_heartbeat(srvaddr, message):
    """Once-per-minute UDP heartbeat.
    Return the "signed long long" data received from server on succcess.
    If the server times out in 0.5 seconds, or sends what we perceive as
    garbage, or we fail to receive from the server at all, return None.

    """
    retnum = None
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.sendto(message, srvaddr)
    # 0.5 seconds of recv timeout should be long enough
    # for communication and short enough for performance.
    sock.settimeout(0.5)
    try:
        retmsg = sock.recvfrom(128)
    except socket.timeout:
        pass    # Ignore it? Don't know what should be done...
    else:
        if retmsg[1] == srvaddr:    # received message is from server
            # Don't ask about the endianness...
            retnum = struct.unpack("<q", retmsg[0][:8])[0]
    finally:
        sock.close()
    return retnum


def login(cfg):
    """The login sequence.  Kill any known background daemon as late
    as possible.  On successful login, create and hand over to the daemon.

    """
    fname = expanduser(cfg["uidfile"])
    url = "http://%s:%s/cgi-bin/do_login" % (cfg["address"], cfg["port"])
    try:
        mac = get_hwaddress(cfg["interface"])
    except ValueError as val_e:
        error("login", "no MAC address information for interface (%s)" % val_e,
                exitcode=4)
    login_data = {"username": cfg["username"],
        "drop": "0",
        "type": "2",
        "n": "100"}
    offset = 0
    n_attempt = 0
    max_attempt = 3
    while n_attempt < max_attempt:  # XXX hard-coded, for testing only
        ourtime = time.time()
        key = makekey(ourtime, offset)
        login_data["password"] = encode_txt(cfg["password"], key)
        login_data["mac"] = encode_txt(mac, key)
        login_postdata = urlencode(login_data)
        # Send data and receive response.
        # Expect either uid or server exception message.
        msg = communicate_to_server(url, login_postdata, "login")
        # Analyse return message.
        try:    # Try as message of success
            num_info = _get_info_from_msg(msg)
        except ValueError:  # Not a message of success
            # Then try decoding as password_error@timestamp format
            try:
                offset = _get_offset_from_msg(ourtime, msg)
            except ValueError:  # Not in password_error@timestamp format
                break
            # XXX hard-coded
            time.sleep(1)
            n_attempt += 1
            continue
        # Success with getting the uid
        # Write uid to file
        try:
            write_uid(num_info[0], fname)
        except IOError as io_e:
            # This should not be an error, but a warning.  Log-in succeeds
            # anyway, you just can't store the uid.
            boiler = "Warning: login:"
            print >> sys.stderr, \
                    "%s can't write UID file (%s)" % (boiler, io_e)
            print >> sys.stderr, \
                    "%s the uid is: %s" % (boiler, num_info[0])
        controlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        try:    # check for anyting left over
            controlsock.bind("/tmp/pysrun.sock")
        except socket.error as so_e:
            if so_e.errno == errno.EADDRINUSE:
                # reclaim leftover process
                try:
                    controlsock.sendto("DIE", "/tmp/pysrun.sock")
                except socket.error:
                    pass
            else:
                raise so_e
        finally:
            controlsock.close()
            # reclaim leftover address
            try:
                os.unlink("/tmp/pysrun.sock")
            except OSError:
                pass
        # Forking into background a heartbeat keeper.
        oldmask = become_daemon()
        daemon(cfg, num_info, oldmask)
        # The control flow should be handed to daemon() in another
        # process so there's no need of leaving the while loop.
    # If the program ever reaches here, we have a server-generated error.
    # We should strip any possible @timestamp tails before signalling.
    msg += "s"  # sentinel
    error("login", msg[:msg.find("@")], server=True)


def _get_info_from_msg(text):
    """Get the information from a well-formed message returned for
    successful login.  Return a list of 5 numbers.

    Tentative format is
    uid, IP address padded with 8 bytes of status string, bytes left,
    unknown field possibly 0, 0 or timestamp of expiry date.

    """
    fields = text.split(",")
    if len(fields) != 5:
        raise ValueError
    nums = [int(n) for n in fields]
    return nums


def _get_offset_from_msg(unixtime, text, prefix="password_error@"):
    """Parse the text, retrieve the timestamp, and calculate the offset.
    Return the numerical offset as a float.

    """
    if not text.startswith(prefix):
        raise ValueError
    theirtime = int(text[len(prefix):])
    return theirtime - unixtime


def _ask_daemon_to_die():
    """Ask daemon to quit.  Ignore possible socket errors, because
    we have nothing to do after this.

    """
    controlsock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    try:
        controlsock.sendto("DIE", "/tmp/pysrun.sock")
    except socket.error:
        pass
    finally:
        controlsock.close()


def logout(cfg):
    """The logout sequence."""
    fname = expanduser(cfg["uidfile"])
    try:
        uid = read_uid(fname)
    except IOError as io_e:
        error("logout", "can't read from UID file (%s)" % io_e,
                exitcode=4)
    except ValueError as val_e:  # read_uid() reads non-uid
        error("logout", "%s" % val_e,
                exitcode=2)
    url = "http://%s:%s/cgi-bin/do_logout" % (cfg["address"], cfg["port"])
    logout_data = {"uid": uid}
    logout_postdata = urlencode(logout_data)
    msg = communicate_to_server(url, logout_postdata, "logout")
    stext = msg.strip()
    if stext != "logout_ok":    # NOTE: Magic constant used.
        error("logout", stext, server=True)
    else:   # Log-out success
        _ask_daemon_to_die()
    return None


def kick(cfg):
    """Kick all users using the account."""
    url = "http://%s:%s/cgi-bin/force_logout" % (cfg["address"], cfg["port"])
    kick_data = {"username": cfg["username"],
            "password": cfg["password"]}
    kick_postdata = urlencode(kick_data)
    msg = communicate_to_server(url, kick_postdata, "kick")
    stext = msg.strip()
    if stext != "logout_ok":    # NOTE: Magic constant used.
        error("kick", stext, server=True)
    else:   # Kick success
        _ask_daemon_to_die()
    return None


def error(prefix, txt, server=False, exitp=True, exitcode=2):
    """Do error messaging.

    prefix announces which component has failed.  txt is a text message
    describing the specific failure.

    If exitp is True, call sys.exit() to exit with exitcode, otherwise don't
    exit and return the message printed.  If exit is False, exitcode is
    ignored.

    The flag server should be set to True if the exception is notified by
    the server.  This causes the pretty-printer to do some extra formatting
    and always exit with code 1.  Therefore, when server is True, neither
    exitp nor exitcode has any effect.

    """
    if server:
        if txt in ERRMSG:
            msg = "Error: %s: server indicates error: %s" % (prefix,
                    ERRMSG[txt])
            exitcode = 1
        else:
            msg = "Error: %s: unknown server error (%s)" % (prefix, txt)
            exitcode = 8
        exitp = True
    else:
        msg = "Error: %s: %s" % (prefix, txt)
    print >> sys.stderr, "%s" % msg
    if exitp:
        sys.exit(exitcode)
    else:
        return msg


def have(keylist, dic):
    """Check whether all keys in keylist are present in dic and all keys
    has values evaluating to True.  Return a boolean.

    """
    return all(key in dic and dic[key] for key in keylist)


def show_usage(fail=True):
    """Show help message.  If fail, the message is written to stderr
    and the program exits with status 2.  If fail is False, write to stdout
    and return None.

    """
    stream = sys.stderr if fail else sys.stdout
    msglist = ["Usage: pysrun [Options] {login|logout|kick}",
            "Options:",
            "  -c FILE       path to configuration file",
            "  -I            propmt interactively for password",
            "  -u USERNAME   account username",
            "  -p PASSWORD   account password",
            "  -a ADDRESS    address of authentication server",
            "  -P PORT       authentication server listening port",
            "  -i INTERFACE  network interface used for MAC address retrieval",
            "  -s FILE       path to session UID storage file",
            "  -d            show debug output",
            "  -h            display this message and exit"]
    print >> stream, "\n".join(msglist)
    if fail:
        sys.exit(2)
    return None


def transform_to_config(inputdic):
    """Translate the keys in inputdic to the corresponding config
    dictionary key name.

    Return the transformed dictionary object useful for updating the config
    dictionary.

    """
    result = {}
    for key, value in inputdic.iteritems():
        if key in OPT_CONFIG_MAP:
            result[OPT_CONFIG_MAP[key]] = value
    return result


def isvalidport(txt):
    """Returns True if txt represents a valid TCP port (in dec)."""
    return txt.isdigit() and int(txt) <= 65535 and int(txt) >= 0


def main():
    optspec = "hc:dI"
    optspec += "".join([("%s:" % key.strip("-")) for key in OPT_CONFIG_MAP])
    # Get options and arguments, emit help message on bad options.
    try:
        oplist, args = getopt.gnu_getopt(sys.argv[1:], optspec)
    except getopt.GetoptError as go_e:
        error("config", "%s" % go_e, exitp=False)
        show_usage(fail=True)  # be explicit
    opdict = dict(oplist)
    if "-h" in opdict:  # Exit as early as possible if "-h" is in options.
        show_usage(fail=False)
        sys.exit(0)
    # Determine the operation from cmdline, fail if none find.
    operation_table = {"login": login,
            "logout": logout,
            "kick": kick}
    valid_oprs = operation_table.viewkeys() & args
    if len(valid_oprs) != 1:  # One and only one operation allowed.
        show_usage(fail=True)
    the_opr = valid_oprs.pop()
    # Update config info from all sources we have.
    config_from_cmdline = transform_to_config(opdict)
    config_path = expanduser(opdict.get("-c", "~/.pysrun.cfg"))
    try:
        config_from_file = read_config_file(config_path, warn=("-d" in opdict))
    except IOError as io_e:
        error("config", "can't read configuration file (%s)" % io_e,
                exitcode=4)
    # Overriding priorities: command-line > config file > defaults.
    CONFIG.update(config_from_file)
    CONFIG.update(config_from_cmdline)
    # Interactive password overrides all other forms of password input.
    if "-I" in opdict and the_opr != "logout":
        CONFIG["password"] = getpass.getpass()
    # Validation of config and its values.
    if not isvalidport(CONFIG["port"]):
        error("config", "invalid port number (%s)" % CONFIG["port"],
                exitcode=2)
    required_keys = {"login": ["username", "password"],
            "logout": ["uidfile"],
            "kick": ["username", "password"]}
    if have(required_keys[the_opr], CONFIG):
        operation_table[the_opr](CONFIG)
    else:
        error("config", "operation \"%s\" requires the option%s %s" %
                (the_opr, "s" if len(required_keys[the_opr]) > 1 else "",
                    " and ".join(required_keys[the_opr])),
                exitcode=2)


if __name__ == "__main__":
    main()
